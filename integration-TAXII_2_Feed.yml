category: Data Enrichment & Threat Intelligence
commonfields:
  id: TAXII 2 Feed
  version: -1
configuration:
- defaultvalue: "true"
  display: Fetch indicators
  name: feed
  required: false
  type: 8
- additionalinfo: Indicators from this integration instance will be marked with this
    reputation
  display: Indicator Reputation
  name: feedReputation
  options:
  - None
  - Good
  - Suspicious
  - Bad
  required: false
  type: 18
- additionalinfo: Reliability of the source providing the intelligence data
  display: Source Reliability
  name: feedReliability
  options:
  - A - Completely reliable
  - B - Usually reliable
  - C - Fairly reliable
  - D - Not usually reliable
  - E - Unreliable
  - F - Reliability cannot be judged
  required: true
  type: 15
- additionalinfo: The Traffic Light Protocol (TLP) designation to apply to indicators
    fetched from the feed
  display: Traffic Light Protocol Color
  name: tlp_color
  options:
  - RED
  - AMBER
  - GREEN
  - WHITE
  required: false
  type: 15
- display: ""
  name: feedExpirationPolicy
  options:
  - never
  - interval
  - indicatorType
  - suddenDeath
  required: false
  type: 17
- display: ""
  name: feedExpirationInterval
  required: false
  type: 1
- defaultvalue: "240"
  display: Feed Fetch Interval
  name: feedFetchInterval
  required: false
  type: 19
- additionalinfo: When selected, the exclusion list is ignored for indicators from
    this feed. This means that if an indicator from this feed is on the exclusion
    list, the indicator might still be added to the system.
  display: Bypass exclusion list
  name: feedBypassExclusionList
  required: false
  type: 8
- display: Discovery Service URL (e.g. https://example.net/taxii)
  name: url
  required: true
  type: 0
- display: Username / API Key (see '?')
  name: credentials
  required: false
  type: 9
- additionalinfo: Indicators will be fetched from this collection. Run "taxii2-get-collections"
    command to get a valid value. If left empty, the instance will try to fetch from
    all the collections in the given discovery service.
  display: Collection Name To Fetch Indicators From
  name: collection_to_fetch
  required: false
  type: 0
- additionalinfo: When enabled, fetch-indicators will try to fetch the entire feed
    for every fetch. When disabled, fetch-indicators will try to fetch just the latest
    entries (since the last fetch).
  defaultvalue: "true"
  display: Full Feed Fetch
  name: fetch_full_feed
  required: false
  type: 8
- additionalinfo: The maximum number of indicators that can be fetched per fetch.
    If this field is left empty, there will be no limit on the number of indicators
    fetched.
  display: Max Indicators Per Fetch (disabled for Full Feed Fetch)
  name: limit
  required: false
  type: 0
- additionalinfo: The time interval for the first fetch (retroactive). <number> <time
    unit> of type minute/hour/day/year. For example, 1 minute, 12 hour
  defaultvalue: 1 year
  display: First Fetch Time
  name: initial_interval
  required: false
  type: 0
- additionalinfo: 'TAXII 2 filter arguments. Comma-separated values, e.g.: `added_after=<date>,revoked=true`.'
  display: Filter Arguments
  name: filter_args
  required: false
  type: 0
- additionalinfo: Set the number of stix object that will be requested with each taxii
    poll (http request). A single fetch is made of several taxii polls. Changing this
    setting can help speed up fetches, or fix issues on slower networks. Please note
    server restrictions may apply, overriding and limiting the "requested limit".
  defaultvalue: "100"
  display: Max STIX Objects Per Poll
  name: limit_per_request
  required: false
  type: 0
- additionalinfo: Choose how to handle complex observations. Two or more Observation
    Expressions MAY be combined using a complex observation operator such as "AND",
    "OR". e.g. `[ IP = 'b' ] AND [ URL = 'd' ]`
  defaultvalue: Skip indicators with more than a single observation
  display: Complex Observation Mode
  name: observation_operator_mode
  options:
  - Create indicator for each observation
  - Skip indicators with more than a single observation
  required: false
  type: 15
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- additionalinfo: Supports CSV values.
  display: Tags
  name: feedTags
  required: false
  type: 0
contentitemexportablefields:
  contentitemfields:
    fromServerVersion: ""
    itemVersion: 1.0.5
    packID: FeedTAXII
    packPropagationLabels:
    - all
    propagationLabels: []
    toServerVersion: ""
description: Ingests indicator feeds from TAXII 2.0 and 2.1 servers.
detaileddescription: |-
  ### Using API Token authentication
  In order to use the integration with an API token you'll first need to change the `Username / API Key (see '?')` field to `_api_token_key`. Following this step, you can now enter the API Token into the `Password` field - this value will be used as an API key.


  ### Using custom authentication header
  In case the TAXII 2 server you're trying to connect to requires a custom authentication header, you'll first need to change the `Username / API Key (see '?')` field to `_header:` and the custom header name, e.g. `_header:custom_auth`. Following this step, you can now enter the custom authentication header value into the `Password` field - this value will be used as a custom authentication header.

  ### Complex Observation Mode
  Two or more Observation Expressions MAY be combined using a complex observation operator such as "AND", "OR", and "FOLLOWEDBY", e.g. `[ IP = 'b' ] AND [ URL = 'd' ]`. These relationships are not represented in CORTEX XSOAR threat intel management indicators. You can opt to create them while ignoring these relations, or you can opt to ignore these expressions - if you choose to ignore these expressions, then no indicators will be created for complex observations.

  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/taxii-2-feed)
display: TAXII 2 Feed
image: data:image/png;base64,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
name: TAXII 2 Feed
script:
  commands:
  - arguments:
    - auto: PREDEFINED
      defaultValue: "false"
      description: Will return only the rawJSON of the indicator object.
      name: raw
      predefined:
      - "true"
      - "false"
    - defaultValue: "10"
      description: Maximum number of indicators to fetch.
      name: limit
    - description: Fetch only indicators that were added to the server after the given
        time. Please provide a <number> and <time unit> of type minute/hour/day. For
        example, 1 minute, 12 hour, 24 days.
      name: added_after
    - description: 'TAXII filter arguments. Comma-separated values, e.g.: "added_after=<date>,revoked=true".'
      name: filter_args
    description: Allows you to test your feed and to make sure you can fetch indicators
      successfuly.
    name: taxii2-get-indicators
    outputs:
    - contextPath: TAXII2.Indicators.type
      description: Indicator type.
      type: String
    - contextPath: TAXII2.Indicators.value
      description: Indicator value.
      type: String
    - contextPath: TAXII2.Indicators.rawJSON
      description: Indicator rawJSON.
      type: String
  - arguments: []
    description: Gets the list of collections from the discovery service.
    name: taxii2-get-collections
    outputs:
    - contextPath: TAXII2.Collections.ID
      description: Collection ID.
      type: String
    - contextPath: TAXII2.Collections.Name
      description: Collection Name.
      type: String
  - arguments: []
    description: 'WARNING: This command will reset your fetch history.'
    name: taxii2-reset-fetch-indicators
  dockerimage: demisto/taxii2:1.0.0.11306
  feed: true
  runonce: false
  script: |2




    from typing import Any, Tuple, Optional

    """ CONSTANT VARIABLES """


    CONTEXT_PREFIX = "TAXII2"
    COMPLEX_OBSERVATION_MODE_SKIP = "Skip indicators with more than a single observation"
    COMPLEX_OBSERVATION_MODE_CREATE_ALL = "Create indicator for each observation"

    """ HELPER FUNCTIONS """


    def try_parse_integer(
        int_to_parse: Any, err_msg: str = "Please provide a valid limit (positive integer)"
    ) -> int:
        """
        Tries to parse an integer, and if fails will throw DemistoException with given err_msg
        """
        if not int_to_parse:
            return int_to_parse
        try:
            res = int(int_to_parse)
        except (TypeError, ValueError):
            raise DemistoException(err_msg)
        return res


    """ COMMAND FUNCTIONS """


    def module_test_command(client, limit, fetch_full_feed):
        if client.collections:
            if fetch_full_feed:
                if limit and limit != -1:
                    return_error(
                        "Configuration Error - Max Indicators Per Fetch is disabled when Full Feed Fetch is enabled"
                    )
            demisto.results("ok")
        else:
            return_error("Could not connect to server")


    def fetch_indicators_command(
        client,
        initial_interval,
        limit,
        last_run_ctx,
        fetch_full_feed: bool = False,
        filter_args: Optional[dict] = None,
    ) -> Tuple[list, dict]:
        """
        Fetch indicators from TAXII 2 server
        :param client: Taxii2FeedClient
        :param initial_interval: initial interval in parse_date_range format
        :param limit: upper limit of indicators to fetch
        :param last_run_ctx: last run dict with {collection_id: last_run_time string}
        :param fetch_full_feed: when set to true, will ignore last run, and try to fetch the entire feed
        :param filter_args: filter args requested by the user
        :return: indicators in cortex TIM format
        """
        if initial_interval:
            initial_interval, _ = parse_date_range(
                initial_interval, date_format=TAXII_TIME_FORMAT
            )
        if filter_args is None:
            filter_args = {}
        last_fetch_time = (
            last_run_ctx.get(client.collection_to_fetch.id)
            if client.collection_to_fetch
            else None
        )
        filter_args["added_after"] = get_added_after(
            fetch_full_feed, initial_interval, last_fetch_time, filter_args
        )

        if client.collection_to_fetch is None:
            # fetch all collections
            if client.collections is None:
                raise DemistoException(ERR_NO_COLL)
            indicators: list = []
            for collection in client.collections:
                client.collection_to_fetch = collection
                filter_args["added_after"] = get_added_after(
                    fetch_full_feed, initial_interval, last_run_ctx.get(collection.id)
                )
                fetched_iocs = client.build_iterator(limit, **filter_args)
                indicators.extend(fetched_iocs)
                if limit >= 0:
                    limit -= len(fetched_iocs)
                    if limit <= 0:
                        break
                last_run_ctx[collection.id] = client.last_fetched_indicator__modified
        else:
            # fetch from a single collection
            indicators = client.build_iterator(limit, **filter_args)
            last_run_ctx[client.collection_to_fetch.id] = (
                client.last_fetched_indicator__modified
                if client.last_fetched_indicator__modified
                else filter_args.get("added_after")
            )
        return indicators, last_run_ctx


    def get_added_after(
        fetch_full_feed, initial_interval, last_fetch_time=None, filter_args=None
    ):
        """
        Creates the added_after param, or extracts it from the filter_args
        :param fetch_full_feed: when set to true, will limit added_after
        :param initial_interval: initial_interval if no
        :param last_fetch_time: last_fetch time value (str)
        :param filter_args: set of filter_args defined by the user to be merged with added_after
        :return: added_after
        """
        if fetch_full_feed:
            return initial_interval

        if not filter_args or "added_after" not in filter_args:
            return last_fetch_time or initial_interval

        return filter_args["added_after"]


    def get_indicators_command(
        client, raw="false", limit=10, added_after=None, filter_args=None
    ):
        """
        Fetch indicators from TAXII 2 server
        :param client: Taxii2FeedClient
        :param raw: When set to "true" will return only rawJSON
        :param limit: upper limit of indicators to fetch
        :param (Optional) added_after: added after time string in parse_date_range format
        :param (Optional) filter_args: filter to be used for taxii poll
        :return: indicators in cortex TIM format
        """
        limit = try_parse_integer(limit)
        filter_args = handle_filter_arg(filter_args)
        if added_after and "added_after" not in filter_args:
            added_after, _ = parse_date_range(added_after, date_format=TAXII_TIME_FORMAT)
            filter_args["added_after"] = added_after
        raw = raw == "true"

        if client.collection_to_fetch is None:
            # fetch all collections
            if client.collections is None:
                raise DemistoException(ERR_NO_COLL)
            indicators: list = []
            for collection in client.collections:
                client.collection_to_fetch = collection
                fetched_iocs = client.build_iterator(limit, **filter_args)
                indicators.extend(fetched_iocs)
                if limit >= 0:
                    limit -= len(fetched_iocs)
                    if limit <= 0:
                        break

        else:
            indicators = client.build_iterator(limit=limit, **filter_args)

        if raw:
            demisto.results({"indicators": [x.get("rawJSON") for x in indicators]})
            return

        md = f"Found {len(indicators)} results:\n" + tableToMarkdown(
            "", indicators, ["value", "type"]
        )
        if indicators:
            return CommandResults(
                outputs_prefix=CONTEXT_PREFIX + ".Indicators",
                outputs_key_field="value",
                outputs=indicators,
                readable_output=md,
            )
        return md


    def get_collections_command(client):
        """
        Get the available collections in the TAXII server
        :param client: FeedClient
        :return: available collections
        """
        collections = list()
        for collection in client.collections:
            collections.append({"Name": collection.title, "ID": collection.id})
        md = tableToMarkdown("TAXII2 Server Collections:", collections, ["Name", "ID"])
        return CommandResults(
            outputs_prefix=CONTEXT_PREFIX + ".Collections",
            outputs_key_field="ID",
            outputs=collections,
            readable_output=md,
        )


    def reset_fetch_command(client):
        """
        Reset the last fetch from the integration context
        """
        demisto.setIntegrationContext({})
        return (
            "Fetch was reset successfully. Your next indicator fetch will collect indicators from "
            'the configured "First Fetch Time"'
        )


    def handle_filter_arg(filter_args=None, delimiter="="):
        """
        Transforms filter arguments (str) to a dict to be used by build_iterator
        :param filter_args: filter_args as typed by the user in the filter_args param
        :param delimiter: delimiter to use between filter_key and filter_val
        :return: filter_args dict with type:indicator {filter_key: filter_value}

        """
        # add filter for indicator types by default
        filter_dict = {"type": "indicator"}
        if filter_args:
            filter_args = argToList(filter_args)
            try:
                for arg in filter_args:
                    key, val = arg.split(delimiter)
                    filter_dict[key] = val
            except ValueError:
                raise DemistoException(
                    "Encountered an error while trying to parse filter_args, please make sure you entered them in the correct format"
                )
        return filter_dict


    def main():
        params = demisto.params()
        args = demisto.args()
        url = params.get("url")
        collection_to_fetch = params.get("collection_to_fetch")
        credentials = params.get("credentials") or {}
        username = credentials.get("identifier")
        password = credentials.get("password")
        proxies = handle_proxy()
        verify_certificate = not params.get("insecure", False)
        skip_complex_mode = COMPLEX_OBSERVATION_MODE_SKIP == params.get(
            "observation_operator_mode"
        )
        feed_tags = argToList(params.get("feedTags"))
        tlp_color = params.get('tlp_color', '')

        initial_interval = params.get("initial_interval")
        fetch_full_feed = params.get("fetch_full_feed") or False
        limit = try_parse_integer(params.get("limit") or -1)
        limit_per_request = try_parse_integer(params.get("limit_per_request"))
        filter_args = handle_filter_arg(params.get("filter_args"))

        command = demisto.command()
        demisto.info(f"Command being called in {CONTEXT_PREFIX} is {command}")
        try:
            client = Taxii2FeedClient(
                url=url,
                collection_to_fetch=collection_to_fetch,
                proxies=proxies,
                verify=verify_certificate,
                skip_complex_mode=skip_complex_mode,
                username=username,
                password=password,
                tags=feed_tags,
                limit_per_request=limit_per_request,
                tlp_color=tlp_color
            )
            client.initialise()
            commands = {
                "taxii2-reset-fetch-indicators": reset_fetch_command,
                "taxii2-get-indicators": get_indicators_command,
                "taxii2-get-collections": get_collections_command,
            }

            if demisto.command() == "test-module":
                # This is the call made when pressing the integration Test button.
                module_test_command(client, limit, fetch_full_feed)

            elif demisto.command() == "fetch-indicators":
                if fetch_full_feed:
                    limit = -1
                integration_ctx = demisto.getIntegrationContext() or {}
                (indicators, integration_ctx) = fetch_indicators_command(
                    client,
                    initial_interval,
                    limit,
                    integration_ctx,
                    fetch_full_feed,
                    filter_args,
                )
                for iter_ in batch(indicators, batch_size=2000):
                    demisto.createIndicators(iter_)

                demisto.setIntegrationContext(integration_ctx)
            else:
                return_results(commands[command](client, **args))  # type: ignore[operator]

        except Exception as e:
            err_msg = f"Failed to execute {command} command. Error: {str(e)}\n\ntraceback: {traceback.format_exc()}"
            if isinstance(e, requests.exceptions.SSLError):
                LOG(err_msg)
                err_msg = (
                    "Encountered an HTTPS certificate error. This error can be ignored by enabling "
                    '"Trust any certificate (not secure)" in the instance configuration.'
                )
            return_error(err_msg)



    ### GENERATED CODE ###
    # This code was inserted in place of an API module.



    from typing import Union, Optional, List, Dict, Tuple
    from requests.sessions import merge_setting, CaseInsensitiveDict
    import re
    import copy
    import types
    import urllib3
    from taxii2client import v20, v21
    from taxii2client.common import TokenAuth, _HTTPConnection

    # disable insecure warnings
    urllib3.disable_warnings()

    # CONSTANTS
    TAXII_VER_2_0 = "2.0"
    TAXII_VER_2_1 = "2.1"

    DFLT_LIMIT_PER_REQUEST = 100
    API_USERNAME = "_api_token_key"
    HEADER_USERNAME = "_header:"

    ERR_NO_COLL = "No collection is available for this user, please make sure you entered the configuration correctly"

    # Pattern Regexes - used to extract indicator type and value
    INDICATOR_OPERATOR_VAL_FORMAT_PATTERN = r"(\w.*?{value}{operator})'(.*?)'"
    INDICATOR_EQUALS_VAL_PATTERN = INDICATOR_OPERATOR_VAL_FORMAT_PATTERN.format(
        value="value", operator="="
    )
    CIDR_ISSUBSET_VAL_PATTERN = INDICATOR_OPERATOR_VAL_FORMAT_PATTERN.format(
        value="value", operator="ISSUBSET"
    )
    CIDR_ISUPPERSET_VAL_PATTERN = INDICATOR_OPERATOR_VAL_FORMAT_PATTERN.format(
        value="value", operator="ISUPPERSET"
    )
    HASHES_EQUALS_VAL_PATTERN = INDICATOR_OPERATOR_VAL_FORMAT_PATTERN.format(
        value=r"hashes\..*?", operator="="
    )

    TAXII_TIME_FORMAT = "%Y-%m-%dT%H:%M:%S.%fZ"
    TAXII_TIME_FORMAT_NO_MS = "%Y-%m-%dT%H:%M:%SZ"

    STIX_2_TYPES_TO_CORTEX_TYPES = {
        "ipv4-addr": FeedIndicatorType.IP,
        "ipv6-addr": FeedIndicatorType.IPv6,
        "domain": FeedIndicatorType.Domain,
        "domain-name": FeedIndicatorType.Domain,
        "url": FeedIndicatorType.URL,
        "md5": FeedIndicatorType.File,
        "sha-1": FeedIndicatorType.File,
        "sha-256": FeedIndicatorType.File,
        "file:hashes": FeedIndicatorType.File,
    }

    STIX_2_TYPES_TO_CORTEX_CIDR_TYPES = {
        "ipv4-addr": FeedIndicatorType.CIDR,
        "ipv6-addr": FeedIndicatorType.IPv6CIDR,
    }


    class Taxii2FeedClient:
        def __init__(
                self,
                url: str,
                collection_to_fetch,
                proxies,
                verify: bool,
                skip_complex_mode: bool = False,
                username: Optional[str] = None,
                password: Optional[str] = None,
                field_map: Optional[dict] = None,
                tags: Optional[list] = None,
                tlp_color: Optional[str] = None,
                limit_per_request: int = DFLT_LIMIT_PER_REQUEST,
        ):
            """
            TAXII 2 Client used to poll and parse indicators in XSOAR formar
            :param url: discovery service URL
            :param collection_to_fetch: Collection to fetch objects from
            :param proxies: proxies used in request
            :param skip_complex_mode: if set to True will skip complex observations
            :param verify: verify https
            :param username: username used for basic authentication OR api_key used for authentication
            :param password: password used for basic authentication
            :param field_map: map used to create fields entry ({field_name: field_value})
            :param tags: custom tags to be added to the created indicator
            :param limit_per_request: Limit the objects requested per poll request
            :param tlp_color: Traffic Light Protocol color
            """
            self._conn = None
            self.server = None
            self.api_root = None
            self.collections = None
            self.last_fetched_indicator__modified = None

            self.collection_to_fetch = collection_to_fetch
            self.skip_complex_mode = skip_complex_mode
            if not limit_per_request:
                limit_per_request = DFLT_LIMIT_PER_REQUEST
            self.limit_per_request = limit_per_request

            self.base_url = url
            self.proxies = proxies
            self.verify = verify

            self.auth = None
            self.auth_header = None
            self.auth_key = None
            if username and password:
                # authentication methods:
                # 1. API Token
                # 2. Authentication Header
                # 3. Basic
                if username == API_USERNAME:
                    self.auth = TokenAuth(key=password)
                elif username.startswith(HEADER_USERNAME):
                    self.auth_header = username.split(HEADER_USERNAME)[1]
                    self.auth_key = password
                else:
                    self.auth = requests.auth.HTTPBasicAuth(username, password)

            self.field_map = field_map if field_map else {}
            self.tags = tags if tags else []
            self.tlp_color = tlp_color
            self.indicator_regexes = [
                re.compile(INDICATOR_EQUALS_VAL_PATTERN),
                re.compile(HASHES_EQUALS_VAL_PATTERN),
            ]
            self.cidr_regexes = [
                re.compile(CIDR_ISSUBSET_VAL_PATTERN),
                re.compile(CIDR_ISUPPERSET_VAL_PATTERN),
            ]

        def init_server(self, version=TAXII_VER_2_0):
            """
            Initializes a server in the requested version
            :param version: taxii version key (either 2.0 or 2.1)
            """
            server_url = urljoin(self.base_url)
            self._conn = _HTTPConnection(
                verify=self.verify, proxies=self.proxies, version=version, auth=self.auth
            )
            if self.auth_header:
                # add auth_header to the session object
                self._conn.session.headers = (  # type: ignore[attr-defined]
                    merge_setting(
                        self._conn.session.headers,  # type: ignore[attr-defined]
                        {self.auth_header: self.auth_key},
                        dict_class=CaseInsensitiveDict,
                    ),
                )
            if version is TAXII_VER_2_0:
                self.server = v20.Server(
                    server_url, verify=self.verify, proxies=self.proxies, conn=self._conn,
                )
            else:
                self.server = v21.Server(
                    server_url, verify=self.verify, proxies=self.proxies, conn=self._conn,
                )

        def init_roots(self):
            """
            Initializes the api roots (used to get taxii server objects)
            """
            if not self.server:
                self.init_server()
            try:
                # try TAXII 2.0
                self.api_root = self.server.api_roots[0]  # type: ignore[union-attr, attr-defined]
                # override _conn - api_root isn't initialized with the right _conn
                self.api_root._conn = self._conn  # type: ignore[attr-defined]
            # (TAXIIServiceException, HTTPError) should suffice, but sometimes it raises another type of HTTPError
            except Exception as e:
                if "406 Client Error" not in str(e):
                    raise e
                # switch to TAXII 2.1
                self.init_server(version=TAXII_VER_2_1)
                self.api_root = self.server.api_roots[0]  # type: ignore[union-attr, attr-defined]
                # override _conn - api_root isn't initialized with the right _conn
                self.api_root._conn = self._conn  # type: ignore[attr-defined]

        def init_collections(self):
            """
            Collects available taxii collections
            """
            self.collections = [x for x in self.api_root.collections]  # type: ignore[union-attr, attr-defined, assignment]

        def init_collection_to_fetch(self, collection_to_fetch=None):
            """
            Tries to initialize `collection_to_fetch` if possible
            """
            if collection_to_fetch is None and isinstance(self.collection_to_fetch, str):
                # self.collection_to_fetch will be changed from str -> Union[v20.Collection, v21.Collection]
                collection_to_fetch = self.collection_to_fetch
            if not self.collections:
                raise DemistoException(ERR_NO_COLL)
            if collection_to_fetch:
                collection_found = False
                for collection in self.collections:
                    if collection.title == collection_to_fetch:
                        self.collection_to_fetch = collection
                        collection_found = True
                        break
                if not collection_found:
                    raise DemistoException(
                        "Could not find the provided Collection name in the available collections. "
                        "Please make sure you entered the name correctly."
                    )

        def initialise(self):
            self.init_server()
            self.init_roots()
            self.init_collections()
            self.init_collection_to_fetch()

        def build_iterator(self, limit: int = -1, **kwargs) -> List[Dict[str, str]]:
            """
            Polls the taxii server and builds a list of cortex indicators objects from the result
            :param limit: max amount of indicators to fetch
            :return: Cortex indicators list
            """
            if not isinstance(self.collection_to_fetch, (v20.Collection, v21.Collection)):
                raise DemistoException(
                    "Could not find a collection to fetch from. "
                    "Please make sure you provided a collection."
                )
            if limit is None:
                limit = -1

            page_size = self.get_page_size(limit, limit)
            if page_size <= 0:
                return []
            envelope = self.poll_collection(page_size, **kwargs)
            indicators = self.extract_indicators_from_envelope_and_parse(envelope, limit)
            return indicators

        def extract_indicators_from_envelope_and_parse(
                self, envelope: Union[types.GeneratorType, Dict[str, str]], limit: int = -1
        ) -> List[Dict[str, str]]:
            """
            Extract indicators from an 2.0 envelope generator, or 2.1 envelope (which then polls and repeats process)
            and parses them as cortex indicators
            :param envelope: envelope containing stix objects
            :param limit: max amount of indicators to fetch
            :return: Cortex indicators list
            """
            indicators = []
            obj_cnt = 0
            # TAXII 2.0
            if isinstance(envelope, types.GeneratorType):
                for sub_envelope in envelope:
                    stix_objects = sub_envelope.get("objects")
                    if not stix_objects:
                        # no fetched objects
                        break
                    obj_cnt += len(stix_objects)
                    indicators.extend(
                        self.parse_indicators_list(
                            self.extract_indicators_from_stix_objects(stix_objects)
                        )
                    )
                    if 0 < limit <= len(indicators):
                        break
            # TAXII 2.1
            elif isinstance(envelope, Dict):
                cur_limit = limit
                stix_objects = envelope.get("objects")
                obj_cnt += len(stix_objects)
                indicators_list = self.extract_indicators_from_stix_objects(stix_objects)
                indicators = self.parse_indicators_list(indicators_list)
                while envelope.get("more", False):
                    page_size = self.get_page_size(limit, cur_limit)
                    envelope = self.collection_to_fetch.get_objects(
                        limit=page_size, next=envelope.get("next", "")
                    )
                    if isinstance(envelope, Dict):
                        stix_objects = envelope.get("objects")
                        obj_cnt += len(stix_objects)
                        extracted_iocs = self.extract_indicators_from_stix_objects(
                            stix_objects
                        )
                        parsed_iocs = self.parse_indicators_list(extracted_iocs)
                        indicators.extend(parsed_iocs)

                        if limit > -1:
                            cur_limit -= len(envelope)  # type: ignore
                            if cur_limit < 0:
                                break
                    else:
                        raise DemistoException(
                            "Error: TAXII 2 client received the following response while requesting "
                            f"indicators: {str(envelope)}\n\nExpected output is json"
                        )
            demisto.debug(
                f"TAXII 2 Feed has extracted {len(indicators)} indicators / {obj_cnt} stix objects"
            )
            if limit > -1:
                return indicators[:limit]
            return indicators

        def poll_collection(
                self, page_size: int, **kwargs
        ) -> Union[types.GeneratorType, Dict[str, str]]:
            """
            Polls a taxii collection
            :param page_size: size of the request page
            """
            get_objects = self.collection_to_fetch.get_objects
            if isinstance(self.collection_to_fetch, v20.Collection):
                envelope = v20.as_pages(get_objects, per_request=page_size, **kwargs)
            else:
                envelope = get_objects(limit=page_size, **kwargs)
            return envelope

        def get_page_size(self, max_limit: int, cur_limit: int) -> int:
            """
            Get a page size given the limit on entries `max_limit` and the limit on the current poll
            :param max_limit: max amount of entries allowed overall
            :param cur_limit: max amount of entries allowed in a page
            :return: page size
            """
            return (
                min(self.limit_per_request, cur_limit)
                if max_limit > -1
                else self.limit_per_request
            )

        @staticmethod
        def extract_indicators_from_stix_objects(
                stix_objs: List[Dict[str, str]]
        ) -> List[Dict[str, str]]:
            """
            Extracts indicators from taxii objects
            :param stix_objs: taxii objects
            :return: indicators in json format
            """
            indicators_objs = [
                item for item in stix_objs if item.get("type") == "indicator"
            ]  # retrieve only indicators

            return indicators_objs

        def parse_indicators_list(
                self, indicators_objs: List[Dict[str, str]]
        ) -> List[Dict[str, str]]:
            """
            Parses a list of indicator objects, and updates the client.latest_fetched_indicator_created
            :param indicators_objs: indicator objects
            :return: Parsed list of indicators
            """
            indicators = []
            if indicators_objs:
                for indicator_obj in indicators_objs:
                    indicators.extend(self.parse_single_indicator(indicator_obj))
                    indicator_modified_str = indicator_obj.get("modified")
                    if self.last_fetched_indicator__modified is None:
                        self.last_fetched_indicator__modified = indicator_modified_str  # type: ignore[assignment]
                    else:
                        last_datetime = self.stix_time_to_datetime(
                            self.last_fetched_indicator__modified
                        )
                        indicator_created_datetime = self.stix_time_to_datetime(
                            indicator_modified_str
                        )
                        if indicator_created_datetime > last_datetime:
                            self.last_fetched_indicator__modified = indicator_modified_str
            return indicators

        def parse_single_indicator(
                self, indicator_obj: Dict[str, str]
        ) -> List[Dict[str, str]]:
            """
            Parses a single indicator object
            :param indicator_obj: indicator object
            :return: list of indicators extracted from the object in cortex format
            """
            field_map = self.field_map if self.field_map else {}
            pattern = indicator_obj.get("pattern")
            indicators = []
            if pattern:
                # this is done in case the server doesn't properly space the operator,
                # supported indicators have no spaces, so this action shouldn't affect extracted values
                trimmed_pattern = pattern.replace(" ", "")

                indicator_groups = self.extract_indicator_groups_from_pattern(
                    trimmed_pattern, self.indicator_regexes
                )
                indicators.extend(
                    self.get_indicators_from_indicator_groups(
                        indicator_groups,
                        indicator_obj,
                        STIX_2_TYPES_TO_CORTEX_TYPES,
                        field_map,
                    )
                )

                cidr_groups = self.extract_indicator_groups_from_pattern(
                    trimmed_pattern, self.cidr_regexes
                )
                indicators.extend(
                    self.get_indicators_from_indicator_groups(
                        cidr_groups,
                        indicator_obj,
                        STIX_2_TYPES_TO_CORTEX_CIDR_TYPES,
                        field_map,
                    )
                )

            return indicators

        def get_indicators_from_indicator_groups(
                self,
                indicator_groups: List[Tuple[str, str]],
                indicator_obj: Dict[str, str],
                indicator_types: Dict[str, str],
                field_map: Dict[str, str],
        ) -> List[Dict[str, str]]:
            """
            Get indicators from indicator regex groups
            :param indicator_groups: caught regex group in pattern of: [`type`, `indicator`]
            :param indicator_obj: taxii indicator object
            :param indicator_types: supported indicator types -> cortex types
            :param field_map: map used to create fields entry ({field_name: field_value})
            :return: Indicators list
            """
            indicators = []
            if indicator_groups:
                for term in indicator_groups:
                    for taxii_type in indicator_types.keys():
                        # term should be list with 2 argument parsed with regex - [`type`, `indicator`]
                        if len(term) == 2 and taxii_type in term[0]:
                            type_ = indicator_types[taxii_type]
                            value = term[1]
                            indicator = self.create_indicator(
                                indicator_obj, type_, value, field_map
                            )
                            indicators.append(indicator)
                            break
            if self.skip_complex_mode and len(indicators) > 1:
                # we managed to pull more than a single indicator - indicating complex relationship
                return []
            return indicators

        def create_indicator(self, indicator_obj, type_, value, field_map):
            """
            Create a cortex indicator from a stix indicator
            :param indicator_obj: rawJSON value of the indicator
            :param type_: cortex type of the indicator
            :param value: indicator value
            :param field_map: field map used for mapping fields ({field_name: field_value})
            :return: Cortex indicator
            """
            ioc_obj_copy = copy.deepcopy(indicator_obj)
            ioc_obj_copy["value"] = value
            ioc_obj_copy["type"] = type_
            indicator = {
                "value": value,
                "type": type_,
                "rawJSON": ioc_obj_copy,
            }
            fields = {}
            tags = list(self.tags)
            # create tags from labels:
            for label in ioc_obj_copy.get("labels", []):
                tags.append(label)

            # add description if able
            if "description" in ioc_obj_copy:
                fields["description"] = ioc_obj_copy["description"]

            # add field_map fields
            for field_name, field_path in field_map.items():
                if field_path in ioc_obj_copy:
                    fields[field_name] = ioc_obj_copy.get(field_path)

            # union of tags and labels
            if "tags" in fields:
                field_tag = fields.get("tags")
                if isinstance(field_tag, list):
                    tags.extend(field_tag)
                else:
                    tags.append(field_tag)

            fields["tags"] = tags

            if self.tlp_color:
                fields["trafficlightprotocol"] = self.tlp_color

            indicator["fields"] = fields
            return indicator

        @staticmethod
        def extract_indicator_groups_from_pattern(
                pattern: str, regexes: List
        ) -> List[Tuple[str, str]]:
            """
            Extracts indicator [`type`, `indicator`] groups from pattern
            :param pattern: stix pattern
            :param regexes: regexes to run to pattern
            :return: extracted indicators list from pattern
            """
            groups: List[Tuple[str, str]] = []
            for regex in regexes:
                find_result = regex.findall(pattern)
                if find_result:
                    groups.extend(find_result)
            return groups

        @staticmethod
        def stix_time_to_datetime(s_time):
            """
            Converts datetime to str in "%Y-%m-%dT%H:%M:%S.%fZ" format
            :param s_time: time in string format
            :return: datetime
            """
            try:
                return datetime.strptime(s_time, TAXII_TIME_FORMAT)
            except ValueError:
                return datetime.strptime(s_time, TAXII_TIME_FORMAT_NO_MS)



    if __name__ in ("__main__", "__builtin__", "builtins"):
        main()
  subtype: python3
  type: python
system: true
